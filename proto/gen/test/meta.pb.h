// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test/meta.proto

#ifndef PROTOBUF_test_2fmeta_2eproto__INCLUDED
#define PROTOBUF_test_2fmeta_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace test {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_test_2fmeta_2eproto();
void protobuf_AssignDesc_test_2fmeta_2eproto();
void protobuf_ShutdownFile_test_2fmeta_2eproto();

class RoleBase;
class RoleHero;
class RoleHeroInfo;
class RolePackage;
class RoleGrowth;
class RoleStage;
class RoleSNS;
class RoleExt;
class Role;
class meta;

enum RoleBase_Gender {
  RoleBase_Gender_MALE = 0,
  RoleBase_Gender_FEMALE = 1
};
bool RoleBase_Gender_IsValid(int value);
const RoleBase_Gender RoleBase_Gender_Gender_MIN = RoleBase_Gender_MALE;
const RoleBase_Gender RoleBase_Gender_Gender_MAX = RoleBase_Gender_FEMALE;
const int RoleBase_Gender_Gender_ARRAYSIZE = RoleBase_Gender_Gender_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoleBase_Gender_descriptor();
inline const ::std::string& RoleBase_Gender_Name(RoleBase_Gender value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoleBase_Gender_descriptor(), value);
}
inline bool RoleBase_Gender_Parse(
    const ::std::string& name, RoleBase_Gender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoleBase_Gender>(
    RoleBase_Gender_descriptor(), name, value);
}
// ===================================================================

class RoleBase : public ::google::protobuf::Message {
 public:
  RoleBase();
  virtual ~RoleBase();

  RoleBase(const RoleBase& from);

  inline RoleBase& operator=(const RoleBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleBase& default_instance();

  void Swap(RoleBase* other);

  // implements Message ----------------------------------------------

  RoleBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleBase& from);
  void MergeFrom(const RoleBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoleBase_Gender Gender;
  static const Gender MALE = RoleBase_Gender_MALE;
  static const Gender FEMALE = RoleBase_Gender_FEMALE;
  static inline bool Gender_IsValid(int value) {
    return RoleBase_Gender_IsValid(value);
  }
  static const Gender Gender_MIN =
    RoleBase_Gender_Gender_MIN;
  static const Gender Gender_MAX =
    RoleBase_Gender_Gender_MAX;
  static const int Gender_ARRAYSIZE =
    RoleBase_Gender_Gender_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gender_descriptor() {
    return RoleBase_Gender_descriptor();
  }
  static inline const ::std::string& Gender_Name(Gender value) {
    return RoleBase_Gender_Name(value);
  }
  static inline bool Gender_Parse(const ::std::string& name,
      Gender* value) {
    return RoleBase_Gender_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .test.RoleBase.Gender gendor = 1 [default = MALE];
  inline bool has_gendor() const;
  inline void clear_gendor();
  static const int kGendorFieldNumber = 1;
  inline ::test::RoleBase_Gender gendor() const;
  inline void set_gendor(::test::RoleBase_Gender value);

  // @@protoc_insertion_point(class_scope:test.RoleBase)
 private:
  inline void set_has_gendor();
  inline void clear_has_gendor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int gendor_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleBase* default_instance_;
};
// -------------------------------------------------------------------

class RoleHero : public ::google::protobuf::Message {
 public:
  RoleHero();
  virtual ~RoleHero();

  RoleHero(const RoleHero& from);

  inline RoleHero& operator=(const RoleHero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleHero& default_instance();

  void Swap(RoleHero* other);

  // implements Message ----------------------------------------------

  RoleHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleHero& from);
  void MergeFrom(const RoleHero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RoleHero)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleHero* default_instance_;
};
// -------------------------------------------------------------------

class RoleHeroInfo : public ::google::protobuf::Message {
 public:
  RoleHeroInfo();
  virtual ~RoleHeroInfo();

  RoleHeroInfo(const RoleHeroInfo& from);

  inline RoleHeroInfo& operator=(const RoleHeroInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleHeroInfo& default_instance();

  void Swap(RoleHeroInfo* other);

  // implements Message ----------------------------------------------

  RoleHeroInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleHeroInfo& from);
  void MergeFrom(const RoleHeroInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .test.RoleHero heros = 1;
  inline int heros_size() const;
  inline void clear_heros();
  static const int kHerosFieldNumber = 1;
  inline const ::test::RoleHero& heros(int index) const;
  inline ::test::RoleHero* mutable_heros(int index);
  inline ::test::RoleHero* add_heros();
  inline const ::google::protobuf::RepeatedPtrField< ::test::RoleHero >&
      heros() const;
  inline ::google::protobuf::RepeatedPtrField< ::test::RoleHero >*
      mutable_heros();

  // @@protoc_insertion_point(class_scope:test.RoleHeroInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::test::RoleHero > heros_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleHeroInfo* default_instance_;
};
// -------------------------------------------------------------------

class RolePackage : public ::google::protobuf::Message {
 public:
  RolePackage();
  virtual ~RolePackage();

  RolePackage(const RolePackage& from);

  inline RolePackage& operator=(const RolePackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RolePackage& default_instance();

  void Swap(RolePackage* other);

  // implements Message ----------------------------------------------

  RolePackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RolePackage& from);
  void MergeFrom(const RolePackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 maxGrid = 1 [default = 0];
  inline bool has_maxgrid() const;
  inline void clear_maxgrid();
  static const int kMaxGridFieldNumber = 1;
  inline ::google::protobuf::uint32 maxgrid() const;
  inline void set_maxgrid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RolePackage)
 private:
  inline void set_has_maxgrid();
  inline void clear_has_maxgrid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 maxgrid_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RolePackage* default_instance_;
};
// -------------------------------------------------------------------

class RoleGrowth : public ::google::protobuf::Message {
 public:
  RoleGrowth();
  virtual ~RoleGrowth();

  RoleGrowth(const RoleGrowth& from);

  inline RoleGrowth& operator=(const RoleGrowth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleGrowth& default_instance();

  void Swap(RoleGrowth* other);

  // implements Message ----------------------------------------------

  RoleGrowth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleGrowth& from);
  void MergeFrom(const RoleGrowth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1 [default = 1];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 exp = 2 [default = 0];
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RoleGrowth)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 exp_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleGrowth* default_instance_;
};
// -------------------------------------------------------------------

class RoleStage : public ::google::protobuf::Message {
 public:
  RoleStage();
  virtual ~RoleStage();

  RoleStage(const RoleStage& from);

  inline RoleStage& operator=(const RoleStage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleStage& default_instance();

  void Swap(RoleStage* other);

  // implements Message ----------------------------------------------

  RoleStage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleStage& from);
  void MergeFrom(const RoleStage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 curStage = 1 [default = 0];
  inline bool has_curstage() const;
  inline void clear_curstage();
  static const int kCurStageFieldNumber = 1;
  inline ::google::protobuf::uint32 curstage() const;
  inline void set_curstage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RoleStage)
 private:
  inline void set_has_curstage();
  inline void clear_has_curstage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 curstage_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleStage* default_instance_;
};
// -------------------------------------------------------------------

class RoleSNS : public ::google::protobuf::Message {
 public:
  RoleSNS();
  virtual ~RoleSNS();

  RoleSNS(const RoleSNS& from);

  inline RoleSNS& operator=(const RoleSNS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleSNS& default_instance();

  void Swap(RoleSNS* other);

  // implements Message ----------------------------------------------

  RoleSNS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleSNS& from);
  void MergeFrom(const RoleSNS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 maxfrinds = 1 [default = 5];
  inline bool has_maxfrinds() const;
  inline void clear_maxfrinds();
  static const int kMaxfrindsFieldNumber = 1;
  inline ::google::protobuf::uint32 maxfrinds() const;
  inline void set_maxfrinds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RoleSNS)
 private:
  inline void set_has_maxfrinds();
  inline void clear_has_maxfrinds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 maxfrinds_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleSNS* default_instance_;
};
// -------------------------------------------------------------------

class RoleExt : public ::google::protobuf::Message {
 public:
  RoleExt();
  virtual ~RoleExt();

  RoleExt(const RoleExt& from);

  inline RoleExt& operator=(const RoleExt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleExt& default_instance();

  void Swap(RoleExt* other);

  // implements Message ----------------------------------------------

  RoleExt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleExt& from);
  void MergeFrom(const RoleExt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 fightcap = 1 [default = 0];
  inline bool has_fightcap() const;
  inline void clear_fightcap();
  static const int kFightcapFieldNumber = 1;
  inline ::google::protobuf::uint32 fightcap() const;
  inline void set_fightcap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:test.RoleExt)
 private:
  inline void set_has_fightcap();
  inline void clear_has_fightcap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fightcap_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static RoleExt* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::Message {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Role& default_instance();

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 rid = 1;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 1;
  inline ::google::protobuf::uint64 rid() const;
  inline void set_rid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .test.RoleBase base = 3;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 3;
  inline const ::test::RoleBase& base() const;
  inline ::test::RoleBase* mutable_base();
  inline ::test::RoleBase* release_base();
  inline void set_allocated_base(::test::RoleBase* base);

  // required .test.RoleHeroInfo hero = 4;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 4;
  inline const ::test::RoleHeroInfo& hero() const;
  inline ::test::RoleHeroInfo* mutable_hero();
  inline ::test::RoleHeroInfo* release_hero();
  inline void set_allocated_hero(::test::RoleHeroInfo* hero);

  // required .test.RolePackage pack = 5;
  inline bool has_pack() const;
  inline void clear_pack();
  static const int kPackFieldNumber = 5;
  inline const ::test::RolePackage& pack() const;
  inline ::test::RolePackage* mutable_pack();
  inline ::test::RolePackage* release_pack();
  inline void set_allocated_pack(::test::RolePackage* pack);

  // required .test.RoleGrowth grow = 6;
  inline bool has_grow() const;
  inline void clear_grow();
  static const int kGrowFieldNumber = 6;
  inline const ::test::RoleGrowth& grow() const;
  inline ::test::RoleGrowth* mutable_grow();
  inline ::test::RoleGrowth* release_grow();
  inline void set_allocated_grow(::test::RoleGrowth* grow);

  // required .test.RoleStage stage = 7;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 7;
  inline const ::test::RoleStage& stage() const;
  inline ::test::RoleStage* mutable_stage();
  inline ::test::RoleStage* release_stage();
  inline void set_allocated_stage(::test::RoleStage* stage);

  // required .test.RoleSNS sns = 8;
  inline bool has_sns() const;
  inline void clear_sns();
  static const int kSnsFieldNumber = 8;
  inline const ::test::RoleSNS& sns() const;
  inline ::test::RoleSNS* mutable_sns();
  inline ::test::RoleSNS* release_sns();
  inline void set_allocated_sns(::test::RoleSNS* sns);

  // required .test.RoleExt ext = 9;
  inline bool has_ext() const;
  inline void clear_ext();
  static const int kExtFieldNumber = 9;
  inline const ::test::RoleExt& ext() const;
  inline ::test::RoleExt* mutable_ext();
  inline ::test::RoleExt* release_ext();
  inline void set_allocated_ext(::test::RoleExt* ext);

  // @@protoc_insertion_point(class_scope:test.Role)
 private:
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_hero();
  inline void clear_has_hero();
  inline void set_has_pack();
  inline void clear_has_pack();
  inline void set_has_grow();
  inline void clear_has_grow();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_sns();
  inline void clear_has_sns();
  inline void set_has_ext();
  inline void clear_has_ext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 rid_;
  ::std::string* name_;
  ::test::RoleBase* base_;
  ::test::RoleHeroInfo* hero_;
  ::test::RolePackage* pack_;
  ::test::RoleGrowth* grow_;
  ::test::RoleStage* stage_;
  ::test::RoleSNS* sns_;
  ::test::RoleExt* ext_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class meta : public ::google::protobuf::Message {
 public:
  meta();
  virtual ~meta();

  meta(const meta& from);

  inline meta& operator=(const meta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const meta& default_instance();

  void Swap(meta* other);

  // implements Message ----------------------------------------------

  meta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const meta& from);
  void MergeFrom(const meta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .test.Role role = 2;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline const ::test::Role& role() const;
  inline ::test::Role* mutable_role();
  inline ::test::Role* release_role();
  inline void set_allocated_role(::test::Role* role);

  // @@protoc_insertion_point(class_scope:test.meta)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_role();
  inline void clear_has_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::test::Role* role_;
  friend void  protobuf_AddDesc_test_2fmeta_2eproto();
  friend void protobuf_AssignDesc_test_2fmeta_2eproto();
  friend void protobuf_ShutdownFile_test_2fmeta_2eproto();

  void InitAsDefaultInstance();
  static meta* default_instance_;
};
// ===================================================================


// ===================================================================

// RoleBase

// required .test.RoleBase.Gender gendor = 1 [default = MALE];
inline bool RoleBase::has_gendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleBase::set_has_gendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleBase::clear_has_gendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleBase::clear_gendor() {
  gendor_ = 0;
  clear_has_gendor();
}
inline ::test::RoleBase_Gender RoleBase::gendor() const {
  // @@protoc_insertion_point(field_get:test.RoleBase.gendor)
  return static_cast< ::test::RoleBase_Gender >(gendor_);
}
inline void RoleBase::set_gendor(::test::RoleBase_Gender value) {
  assert(::test::RoleBase_Gender_IsValid(value));
  set_has_gendor();
  gendor_ = value;
  // @@protoc_insertion_point(field_set:test.RoleBase.gendor)
}

// -------------------------------------------------------------------

// RoleHero

// required uint32 id = 1 [default = 0];
inline bool RoleHero::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleHero::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleHero::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleHero::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RoleHero::id() const {
  // @@protoc_insertion_point(field_get:test.RoleHero.id)
  return id_;
}
inline void RoleHero::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:test.RoleHero.id)
}

// -------------------------------------------------------------------

// RoleHeroInfo

// repeated .test.RoleHero heros = 1;
inline int RoleHeroInfo::heros_size() const {
  return heros_.size();
}
inline void RoleHeroInfo::clear_heros() {
  heros_.Clear();
}
inline const ::test::RoleHero& RoleHeroInfo::heros(int index) const {
  // @@protoc_insertion_point(field_get:test.RoleHeroInfo.heros)
  return heros_.Get(index);
}
inline ::test::RoleHero* RoleHeroInfo::mutable_heros(int index) {
  // @@protoc_insertion_point(field_mutable:test.RoleHeroInfo.heros)
  return heros_.Mutable(index);
}
inline ::test::RoleHero* RoleHeroInfo::add_heros() {
  // @@protoc_insertion_point(field_add:test.RoleHeroInfo.heros)
  return heros_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::test::RoleHero >&
RoleHeroInfo::heros() const {
  // @@protoc_insertion_point(field_list:test.RoleHeroInfo.heros)
  return heros_;
}
inline ::google::protobuf::RepeatedPtrField< ::test::RoleHero >*
RoleHeroInfo::mutable_heros() {
  // @@protoc_insertion_point(field_mutable_list:test.RoleHeroInfo.heros)
  return &heros_;
}

// -------------------------------------------------------------------

// RolePackage

// required uint32 maxGrid = 1 [default = 0];
inline bool RolePackage::has_maxgrid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RolePackage::set_has_maxgrid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RolePackage::clear_has_maxgrid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RolePackage::clear_maxgrid() {
  maxgrid_ = 0u;
  clear_has_maxgrid();
}
inline ::google::protobuf::uint32 RolePackage::maxgrid() const {
  // @@protoc_insertion_point(field_get:test.RolePackage.maxGrid)
  return maxgrid_;
}
inline void RolePackage::set_maxgrid(::google::protobuf::uint32 value) {
  set_has_maxgrid();
  maxgrid_ = value;
  // @@protoc_insertion_point(field_set:test.RolePackage.maxGrid)
}

// -------------------------------------------------------------------

// RoleGrowth

// required uint32 level = 1 [default = 1];
inline bool RoleGrowth::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleGrowth::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleGrowth::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleGrowth::clear_level() {
  level_ = 1u;
  clear_has_level();
}
inline ::google::protobuf::uint32 RoleGrowth::level() const {
  // @@protoc_insertion_point(field_get:test.RoleGrowth.level)
  return level_;
}
inline void RoleGrowth::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:test.RoleGrowth.level)
}

// required uint32 exp = 2 [default = 0];
inline bool RoleGrowth::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleGrowth::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleGrowth::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleGrowth::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 RoleGrowth::exp() const {
  // @@protoc_insertion_point(field_get:test.RoleGrowth.exp)
  return exp_;
}
inline void RoleGrowth::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:test.RoleGrowth.exp)
}

// -------------------------------------------------------------------

// RoleStage

// required uint32 curStage = 1 [default = 0];
inline bool RoleStage::has_curstage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleStage::set_has_curstage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleStage::clear_has_curstage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleStage::clear_curstage() {
  curstage_ = 0u;
  clear_has_curstage();
}
inline ::google::protobuf::uint32 RoleStage::curstage() const {
  // @@protoc_insertion_point(field_get:test.RoleStage.curStage)
  return curstage_;
}
inline void RoleStage::set_curstage(::google::protobuf::uint32 value) {
  set_has_curstage();
  curstage_ = value;
  // @@protoc_insertion_point(field_set:test.RoleStage.curStage)
}

// -------------------------------------------------------------------

// RoleSNS

// required uint32 maxfrinds = 1 [default = 5];
inline bool RoleSNS::has_maxfrinds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleSNS::set_has_maxfrinds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleSNS::clear_has_maxfrinds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleSNS::clear_maxfrinds() {
  maxfrinds_ = 5u;
  clear_has_maxfrinds();
}
inline ::google::protobuf::uint32 RoleSNS::maxfrinds() const {
  // @@protoc_insertion_point(field_get:test.RoleSNS.maxfrinds)
  return maxfrinds_;
}
inline void RoleSNS::set_maxfrinds(::google::protobuf::uint32 value) {
  set_has_maxfrinds();
  maxfrinds_ = value;
  // @@protoc_insertion_point(field_set:test.RoleSNS.maxfrinds)
}

// -------------------------------------------------------------------

// RoleExt

// required uint32 fightcap = 1 [default = 0];
inline bool RoleExt::has_fightcap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleExt::set_has_fightcap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleExt::clear_has_fightcap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleExt::clear_fightcap() {
  fightcap_ = 0u;
  clear_has_fightcap();
}
inline ::google::protobuf::uint32 RoleExt::fightcap() const {
  // @@protoc_insertion_point(field_get:test.RoleExt.fightcap)
  return fightcap_;
}
inline void RoleExt::set_fightcap(::google::protobuf::uint32 value) {
  set_has_fightcap();
  fightcap_ = value;
  // @@protoc_insertion_point(field_set:test.RoleExt.fightcap)
}

// -------------------------------------------------------------------

// Role

// required uint64 rid = 1;
inline bool Role::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_rid() {
  rid_ = GOOGLE_ULONGLONG(0);
  clear_has_rid();
}
inline ::google::protobuf::uint64 Role::rid() const {
  // @@protoc_insertion_point(field_get:test.Role.rid)
  return rid_;
}
inline void Role::set_rid(::google::protobuf::uint64 value) {
  set_has_rid();
  rid_ = value;
  // @@protoc_insertion_point(field_set:test.Role.rid)
}

// required string name = 2;
inline bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:test.Role.name)
  return *name_;
}
inline void Role::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:test.Role.name)
}
inline void Role::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:test.Role.name)
}
inline void Role::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:test.Role.name)
}
inline ::std::string* Role::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:test.Role.name)
  return name_;
}
inline ::std::string* Role::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Role::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.name)
}

// required .test.RoleBase base = 3;
inline bool Role::has_base() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role::set_has_base() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role::clear_has_base() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role::clear_base() {
  if (base_ != NULL) base_->::test::RoleBase::Clear();
  clear_has_base();
}
inline const ::test::RoleBase& Role::base() const {
  // @@protoc_insertion_point(field_get:test.Role.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::test::RoleBase* Role::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::test::RoleBase;
  // @@protoc_insertion_point(field_mutable:test.Role.base)
  return base_;
}
inline ::test::RoleBase* Role::release_base() {
  clear_has_base();
  ::test::RoleBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline void Role::set_allocated_base(::test::RoleBase* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.base)
}

// required .test.RoleHeroInfo hero = 4;
inline bool Role::has_hero() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role::set_has_hero() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role::clear_has_hero() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role::clear_hero() {
  if (hero_ != NULL) hero_->::test::RoleHeroInfo::Clear();
  clear_has_hero();
}
inline const ::test::RoleHeroInfo& Role::hero() const {
  // @@protoc_insertion_point(field_get:test.Role.hero)
  return hero_ != NULL ? *hero_ : *default_instance_->hero_;
}
inline ::test::RoleHeroInfo* Role::mutable_hero() {
  set_has_hero();
  if (hero_ == NULL) hero_ = new ::test::RoleHeroInfo;
  // @@protoc_insertion_point(field_mutable:test.Role.hero)
  return hero_;
}
inline ::test::RoleHeroInfo* Role::release_hero() {
  clear_has_hero();
  ::test::RoleHeroInfo* temp = hero_;
  hero_ = NULL;
  return temp;
}
inline void Role::set_allocated_hero(::test::RoleHeroInfo* hero) {
  delete hero_;
  hero_ = hero;
  if (hero) {
    set_has_hero();
  } else {
    clear_has_hero();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.hero)
}

// required .test.RolePackage pack = 5;
inline bool Role::has_pack() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role::set_has_pack() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role::clear_has_pack() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role::clear_pack() {
  if (pack_ != NULL) pack_->::test::RolePackage::Clear();
  clear_has_pack();
}
inline const ::test::RolePackage& Role::pack() const {
  // @@protoc_insertion_point(field_get:test.Role.pack)
  return pack_ != NULL ? *pack_ : *default_instance_->pack_;
}
inline ::test::RolePackage* Role::mutable_pack() {
  set_has_pack();
  if (pack_ == NULL) pack_ = new ::test::RolePackage;
  // @@protoc_insertion_point(field_mutable:test.Role.pack)
  return pack_;
}
inline ::test::RolePackage* Role::release_pack() {
  clear_has_pack();
  ::test::RolePackage* temp = pack_;
  pack_ = NULL;
  return temp;
}
inline void Role::set_allocated_pack(::test::RolePackage* pack) {
  delete pack_;
  pack_ = pack;
  if (pack) {
    set_has_pack();
  } else {
    clear_has_pack();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.pack)
}

// required .test.RoleGrowth grow = 6;
inline bool Role::has_grow() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Role::set_has_grow() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Role::clear_has_grow() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Role::clear_grow() {
  if (grow_ != NULL) grow_->::test::RoleGrowth::Clear();
  clear_has_grow();
}
inline const ::test::RoleGrowth& Role::grow() const {
  // @@protoc_insertion_point(field_get:test.Role.grow)
  return grow_ != NULL ? *grow_ : *default_instance_->grow_;
}
inline ::test::RoleGrowth* Role::mutable_grow() {
  set_has_grow();
  if (grow_ == NULL) grow_ = new ::test::RoleGrowth;
  // @@protoc_insertion_point(field_mutable:test.Role.grow)
  return grow_;
}
inline ::test::RoleGrowth* Role::release_grow() {
  clear_has_grow();
  ::test::RoleGrowth* temp = grow_;
  grow_ = NULL;
  return temp;
}
inline void Role::set_allocated_grow(::test::RoleGrowth* grow) {
  delete grow_;
  grow_ = grow;
  if (grow) {
    set_has_grow();
  } else {
    clear_has_grow();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.grow)
}

// required .test.RoleStage stage = 7;
inline bool Role::has_stage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Role::set_has_stage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Role::clear_has_stage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Role::clear_stage() {
  if (stage_ != NULL) stage_->::test::RoleStage::Clear();
  clear_has_stage();
}
inline const ::test::RoleStage& Role::stage() const {
  // @@protoc_insertion_point(field_get:test.Role.stage)
  return stage_ != NULL ? *stage_ : *default_instance_->stage_;
}
inline ::test::RoleStage* Role::mutable_stage() {
  set_has_stage();
  if (stage_ == NULL) stage_ = new ::test::RoleStage;
  // @@protoc_insertion_point(field_mutable:test.Role.stage)
  return stage_;
}
inline ::test::RoleStage* Role::release_stage() {
  clear_has_stage();
  ::test::RoleStage* temp = stage_;
  stage_ = NULL;
  return temp;
}
inline void Role::set_allocated_stage(::test::RoleStage* stage) {
  delete stage_;
  stage_ = stage;
  if (stage) {
    set_has_stage();
  } else {
    clear_has_stage();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.stage)
}

// required .test.RoleSNS sns = 8;
inline bool Role::has_sns() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Role::set_has_sns() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Role::clear_has_sns() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Role::clear_sns() {
  if (sns_ != NULL) sns_->::test::RoleSNS::Clear();
  clear_has_sns();
}
inline const ::test::RoleSNS& Role::sns() const {
  // @@protoc_insertion_point(field_get:test.Role.sns)
  return sns_ != NULL ? *sns_ : *default_instance_->sns_;
}
inline ::test::RoleSNS* Role::mutable_sns() {
  set_has_sns();
  if (sns_ == NULL) sns_ = new ::test::RoleSNS;
  // @@protoc_insertion_point(field_mutable:test.Role.sns)
  return sns_;
}
inline ::test::RoleSNS* Role::release_sns() {
  clear_has_sns();
  ::test::RoleSNS* temp = sns_;
  sns_ = NULL;
  return temp;
}
inline void Role::set_allocated_sns(::test::RoleSNS* sns) {
  delete sns_;
  sns_ = sns;
  if (sns) {
    set_has_sns();
  } else {
    clear_has_sns();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.sns)
}

// required .test.RoleExt ext = 9;
inline bool Role::has_ext() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Role::set_has_ext() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Role::clear_has_ext() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Role::clear_ext() {
  if (ext_ != NULL) ext_->::test::RoleExt::Clear();
  clear_has_ext();
}
inline const ::test::RoleExt& Role::ext() const {
  // @@protoc_insertion_point(field_get:test.Role.ext)
  return ext_ != NULL ? *ext_ : *default_instance_->ext_;
}
inline ::test::RoleExt* Role::mutable_ext() {
  set_has_ext();
  if (ext_ == NULL) ext_ = new ::test::RoleExt;
  // @@protoc_insertion_point(field_mutable:test.Role.ext)
  return ext_;
}
inline ::test::RoleExt* Role::release_ext() {
  clear_has_ext();
  ::test::RoleExt* temp = ext_;
  ext_ = NULL;
  return temp;
}
inline void Role::set_allocated_ext(::test::RoleExt* ext) {
  delete ext_;
  ext_ = ext;
  if (ext) {
    set_has_ext();
  } else {
    clear_has_ext();
  }
  // @@protoc_insertion_point(field_set_allocated:test.Role.ext)
}

// -------------------------------------------------------------------

// meta

// required string version = 1;
inline bool meta::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void meta::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void meta::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void meta::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& meta::version() const {
  // @@protoc_insertion_point(field_get:test.meta.version)
  return *version_;
}
inline void meta::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:test.meta.version)
}
inline void meta::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:test.meta.version)
}
inline void meta::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:test.meta.version)
}
inline ::std::string* meta::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:test.meta.version)
  return version_;
}
inline ::std::string* meta::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void meta::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:test.meta.version)
}

// optional .test.Role role = 2;
inline bool meta::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void meta::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void meta::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void meta::clear_role() {
  if (role_ != NULL) role_->::test::Role::Clear();
  clear_has_role();
}
inline const ::test::Role& meta::role() const {
  // @@protoc_insertion_point(field_get:test.meta.role)
  return role_ != NULL ? *role_ : *default_instance_->role_;
}
inline ::test::Role* meta::mutable_role() {
  set_has_role();
  if (role_ == NULL) role_ = new ::test::Role;
  // @@protoc_insertion_point(field_mutable:test.meta.role)
  return role_;
}
inline ::test::Role* meta::release_role() {
  clear_has_role();
  ::test::Role* temp = role_;
  role_ = NULL;
  return temp;
}
inline void meta::set_allocated_role(::test::Role* role) {
  delete role_;
  role_ = role;
  if (role) {
    set_has_role();
  } else {
    clear_has_role();
  }
  // @@protoc_insertion_point(field_set_allocated:test.meta.role)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace test

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::test::RoleBase_Gender> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::test::RoleBase_Gender>() {
  return ::test::RoleBase_Gender_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2fmeta_2eproto__INCLUDED
