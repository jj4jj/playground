// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: res/task.proto

#ifndef PROTOBUF_res_2ftask_2eproto__INCLUDED
#define PROTOBUF_res_2ftask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace res {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_res_2ftask_2eproto();
void protobuf_AssignDesc_res_2ftask_2eproto();
void protobuf_ShutdownFile_res_2ftask_2eproto();

class TaskObj;
class TaskObj__CName;
class Task;
class Task__PrimaryKey;
class Task__CName;
class TaskTable;

// ===================================================================

class TaskObj__CName : public ::google::protobuf::Message {
 public:
  TaskObj__CName();
  virtual ~TaskObj__CName();

  TaskObj__CName(const TaskObj__CName& from);

  inline TaskObj__CName& operator=(const TaskObj__CName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskObj__CName& default_instance();

  void Swap(TaskObj__CName* other);

  // implements Message ----------------------------------------------

  TaskObj__CName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskObj__CName& from);
  void MergeFrom(const TaskObj__CName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string event = 1 [default = "\344\272\213\344\273\266"];
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::std::string& event() const;
  inline void set_event(const ::std::string& value);
  inline void set_event(const char* value);
  inline void set_event(const char* value, size_t size);
  inline ::std::string* mutable_event();
  inline ::std::string* release_event();
  inline void set_allocated_event(::std::string* event);

  // optional string param = 2 [default = "\345\217\202\346\225\260"];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // optional string value = 3 [default = "\350\246\201\346\261\202\345\200\274"];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string method = 4 [default = "\346\233\264\346\226\260\346\226\271\345\274\217"];
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 4;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // @@protoc_insertion_point(class_scope:res.TaskObj._CName)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_method();
  inline void clear_has_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_event_;
  ::std::string* event_;
  static ::std::string* _default_param_;
  ::std::string* param_;
  static ::std::string* _default_value_;
  ::std::string* value_;
  static ::std::string* _default_method_;
  ::std::string* method_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static TaskObj__CName* default_instance_;
};
// -------------------------------------------------------------------

class TaskObj : public ::google::protobuf::Message {
 public:
  TaskObj();
  virtual ~TaskObj();

  TaskObj(const TaskObj& from);

  inline TaskObj& operator=(const TaskObj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskObj& default_instance();

  void Swap(TaskObj* other);

  // implements Message ----------------------------------------------

  TaskObj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskObj& from);
  void MergeFrom(const TaskObj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TaskObj__CName _CName;

  // accessors -------------------------------------------------------

  // optional uint32 event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline ::google::protobuf::uint32 event() const;
  inline void set_event(::google::protobuf::uint32 value);

  // optional uint32 param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 method = 4;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 4;
  inline ::google::protobuf::uint32 method() const;
  inline void set_method(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:res.TaskObj)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_method();
  inline void clear_has_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 event_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 method_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static TaskObj* default_instance_;
};
// -------------------------------------------------------------------

class Task__PrimaryKey : public ::google::protobuf::Message {
 public:
  Task__PrimaryKey();
  virtual ~Task__PrimaryKey();

  Task__PrimaryKey(const Task__PrimaryKey& from);

  inline Task__PrimaryKey& operator=(const Task__PrimaryKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task__PrimaryKey& default_instance();

  void Swap(Task__PrimaryKey* other);

  // implements Message ----------------------------------------------

  Task__PrimaryKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task__PrimaryKey& from);
  void MergeFrom(const Task__PrimaryKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:res.Task._PrimaryKey)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static Task__PrimaryKey* default_instance_;
};
// -------------------------------------------------------------------

class Task__CName : public ::google::protobuf::Message {
 public:
  Task__CName();
  virtual ~Task__CName();

  Task__CName(const Task__CName& from);

  inline Task__CName& operator=(const Task__CName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task__CName& default_instance();

  void Swap(Task__CName* other);

  // implements Message ----------------------------------------------

  Task__CName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task__CName& from);
  void MergeFrom(const Task__CName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1 [default = "ID"];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2 [default = "\345\220\215\345\255\227"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 3 [default = "\346\217\217\350\277\260"];
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string obj = 4 [default = "\347\233\256\346\240\207"];
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 4;
  inline const ::std::string& obj() const;
  inline void set_obj(const ::std::string& value);
  inline void set_obj(const char* value);
  inline void set_obj(const char* value, size_t size);
  inline ::std::string* mutable_obj();
  inline ::std::string* release_obj();
  inline void set_allocated_obj(::std::string* obj);

  // optional string type = 5 [default = "\347\261\273\345\236\213"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:res.Task._CName)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_obj();
  inline void clear_has_obj();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_id_;
  ::std::string* id_;
  static ::std::string* _default_name_;
  ::std::string* name_;
  static ::std::string* _default_desc_;
  ::std::string* desc_;
  static ::std::string* _default_obj_;
  ::std::string* obj_;
  static ::std::string* _default_type_;
  ::std::string* type_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static Task__CName* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Task__PrimaryKey _PrimaryKey;
  typedef Task__CName _CName;

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional .res.TaskObj obj = 5;
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 5;
  inline const ::res::TaskObj& obj() const;
  inline ::res::TaskObj* mutable_obj();
  inline ::res::TaskObj* release_obj();
  inline void set_allocated_obj(::res::TaskObj* obj);

  // @@protoc_insertion_point(class_scope:res.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_obj();
  inline void clear_has_obj();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::std::string* name_;
  ::std::string* desc_;
  ::res::TaskObj* obj_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class TaskTable : public ::google::protobuf::Message {
 public:
  TaskTable();
  virtual ~TaskTable();

  TaskTable(const TaskTable& from);

  inline TaskTable& operator=(const TaskTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskTable& default_instance();

  void Swap(TaskTable* other);

  // implements Message ----------------------------------------------

  TaskTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskTable& from);
  void MergeFrom(const TaskTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .res.Task list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::res::Task& list(int index) const;
  inline ::res::Task* mutable_list(int index);
  inline ::res::Task* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::res::Task >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::res::Task >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:res.TaskTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::res::Task > list_;
  friend void  protobuf_AddDesc_res_2ftask_2eproto();
  friend void protobuf_AssignDesc_res_2ftask_2eproto();
  friend void protobuf_ShutdownFile_res_2ftask_2eproto();

  void InitAsDefaultInstance();
  static TaskTable* default_instance_;
};
// ===================================================================


// ===================================================================

// TaskObj__CName

// optional string event = 1 [default = "\344\272\213\344\273\266"];
inline bool TaskObj__CName::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskObj__CName::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskObj__CName::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskObj__CName::clear_event() {
  if (event_ != _default_event_) {
    event_->assign(*_default_event_);
  }
  clear_has_event();
}
inline const ::std::string& TaskObj__CName::event() const {
  // @@protoc_insertion_point(field_get:res.TaskObj._CName.event)
  return *event_;
}
inline void TaskObj__CName::set_event(const ::std::string& value) {
  set_has_event();
  if (event_ == _default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
  // @@protoc_insertion_point(field_set:res.TaskObj._CName.event)
}
inline void TaskObj__CName::set_event(const char* value) {
  set_has_event();
  if (event_ == _default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.TaskObj._CName.event)
}
inline void TaskObj__CName::set_event(const char* value, size_t size) {
  set_has_event();
  if (event_ == _default_event_) {
    event_ = new ::std::string;
  }
  event_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.TaskObj._CName.event)
}
inline ::std::string* TaskObj__CName::mutable_event() {
  set_has_event();
  if (event_ == _default_event_) {
    event_ = new ::std::string(*_default_event_);
  }
  // @@protoc_insertion_point(field_mutable:res.TaskObj._CName.event)
  return event_;
}
inline ::std::string* TaskObj__CName::release_event() {
  clear_has_event();
  if (event_ == _default_event_) {
    return NULL;
  } else {
    ::std::string* temp = event_;
    event_ = const_cast< ::std::string*>(_default_event_);
    return temp;
  }
}
inline void TaskObj__CName::set_allocated_event(::std::string* event) {
  if (event_ != _default_event_) {
    delete event_;
  }
  if (event) {
    set_has_event();
    event_ = event;
  } else {
    clear_has_event();
    event_ = const_cast< ::std::string*>(_default_event_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.TaskObj._CName.event)
}

// optional string param = 2 [default = "\345\217\202\346\225\260"];
inline bool TaskObj__CName::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskObj__CName::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskObj__CName::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskObj__CName::clear_param() {
  if (param_ != _default_param_) {
    param_->assign(*_default_param_);
  }
  clear_has_param();
}
inline const ::std::string& TaskObj__CName::param() const {
  // @@protoc_insertion_point(field_get:res.TaskObj._CName.param)
  return *param_;
}
inline void TaskObj__CName::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == _default_param_) {
    param_ = new ::std::string;
  }
  param_->assign(value);
  // @@protoc_insertion_point(field_set:res.TaskObj._CName.param)
}
inline void TaskObj__CName::set_param(const char* value) {
  set_has_param();
  if (param_ == _default_param_) {
    param_ = new ::std::string;
  }
  param_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.TaskObj._CName.param)
}
inline void TaskObj__CName::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == _default_param_) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.TaskObj._CName.param)
}
inline ::std::string* TaskObj__CName::mutable_param() {
  set_has_param();
  if (param_ == _default_param_) {
    param_ = new ::std::string(*_default_param_);
  }
  // @@protoc_insertion_point(field_mutable:res.TaskObj._CName.param)
  return param_;
}
inline ::std::string* TaskObj__CName::release_param() {
  clear_has_param();
  if (param_ == _default_param_) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(_default_param_);
    return temp;
  }
}
inline void TaskObj__CName::set_allocated_param(::std::string* param) {
  if (param_ != _default_param_) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(_default_param_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.TaskObj._CName.param)
}

// optional string value = 3 [default = "\350\246\201\346\261\202\345\200\274"];
inline bool TaskObj__CName::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskObj__CName::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskObj__CName::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskObj__CName::clear_value() {
  if (value_ != _default_value_) {
    value_->assign(*_default_value_);
  }
  clear_has_value();
}
inline const ::std::string& TaskObj__CName::value() const {
  // @@protoc_insertion_point(field_get:res.TaskObj._CName.value)
  return *value_;
}
inline void TaskObj__CName::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == _default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:res.TaskObj._CName.value)
}
inline void TaskObj__CName::set_value(const char* value) {
  set_has_value();
  if (value_ == _default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.TaskObj._CName.value)
}
inline void TaskObj__CName::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == _default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.TaskObj._CName.value)
}
inline ::std::string* TaskObj__CName::mutable_value() {
  set_has_value();
  if (value_ == _default_value_) {
    value_ = new ::std::string(*_default_value_);
  }
  // @@protoc_insertion_point(field_mutable:res.TaskObj._CName.value)
  return value_;
}
inline ::std::string* TaskObj__CName::release_value() {
  clear_has_value();
  if (value_ == _default_value_) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(_default_value_);
    return temp;
  }
}
inline void TaskObj__CName::set_allocated_value(::std::string* value) {
  if (value_ != _default_value_) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(_default_value_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.TaskObj._CName.value)
}

// optional string method = 4 [default = "\346\233\264\346\226\260\346\226\271\345\274\217"];
inline bool TaskObj__CName::has_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskObj__CName::set_has_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskObj__CName::clear_has_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskObj__CName::clear_method() {
  if (method_ != _default_method_) {
    method_->assign(*_default_method_);
  }
  clear_has_method();
}
inline const ::std::string& TaskObj__CName::method() const {
  // @@protoc_insertion_point(field_get:res.TaskObj._CName.method)
  return *method_;
}
inline void TaskObj__CName::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == _default_method_) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:res.TaskObj._CName.method)
}
inline void TaskObj__CName::set_method(const char* value) {
  set_has_method();
  if (method_ == _default_method_) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.TaskObj._CName.method)
}
inline void TaskObj__CName::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == _default_method_) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.TaskObj._CName.method)
}
inline ::std::string* TaskObj__CName::mutable_method() {
  set_has_method();
  if (method_ == _default_method_) {
    method_ = new ::std::string(*_default_method_);
  }
  // @@protoc_insertion_point(field_mutable:res.TaskObj._CName.method)
  return method_;
}
inline ::std::string* TaskObj__CName::release_method() {
  clear_has_method();
  if (method_ == _default_method_) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(_default_method_);
    return temp;
  }
}
inline void TaskObj__CName::set_allocated_method(::std::string* method) {
  if (method_ != _default_method_) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(_default_method_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.TaskObj._CName.method)
}

// -------------------------------------------------------------------

// TaskObj

// optional uint32 event = 1;
inline bool TaskObj::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskObj::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskObj::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskObj::clear_event() {
  event_ = 0u;
  clear_has_event();
}
inline ::google::protobuf::uint32 TaskObj::event() const {
  // @@protoc_insertion_point(field_get:res.TaskObj.event)
  return event_;
}
inline void TaskObj::set_event(::google::protobuf::uint32 value) {
  set_has_event();
  event_ = value;
  // @@protoc_insertion_point(field_set:res.TaskObj.event)
}

// optional uint32 param = 2;
inline bool TaskObj::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskObj::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskObj::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskObj::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 TaskObj::param() const {
  // @@protoc_insertion_point(field_get:res.TaskObj.param)
  return param_;
}
inline void TaskObj::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:res.TaskObj.param)
}

// optional uint32 value = 3;
inline bool TaskObj::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskObj::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskObj::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskObj::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TaskObj::value() const {
  // @@protoc_insertion_point(field_get:res.TaskObj.value)
  return value_;
}
inline void TaskObj::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:res.TaskObj.value)
}

// optional uint32 method = 4;
inline bool TaskObj::has_method() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskObj::set_has_method() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskObj::clear_has_method() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskObj::clear_method() {
  method_ = 0u;
  clear_has_method();
}
inline ::google::protobuf::uint32 TaskObj::method() const {
  // @@protoc_insertion_point(field_get:res.TaskObj.method)
  return method_;
}
inline void TaskObj::set_method(::google::protobuf::uint32 value) {
  set_has_method();
  method_ = value;
  // @@protoc_insertion_point(field_set:res.TaskObj.method)
}

// -------------------------------------------------------------------

// Task__PrimaryKey

// optional uint32 id = 1;
inline bool Task__PrimaryKey::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task__PrimaryKey::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task__PrimaryKey::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task__PrimaryKey::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Task__PrimaryKey::id() const {
  // @@protoc_insertion_point(field_get:res.Task._PrimaryKey.id)
  return id_;
}
inline void Task__PrimaryKey::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:res.Task._PrimaryKey.id)
}

// -------------------------------------------------------------------

// Task__CName

// optional string id = 1 [default = "ID"];
inline bool Task__CName::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task__CName::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task__CName::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task__CName::clear_id() {
  if (id_ != _default_id_) {
    id_->assign(*_default_id_);
  }
  clear_has_id();
}
inline const ::std::string& Task__CName::id() const {
  // @@protoc_insertion_point(field_get:res.Task._CName.id)
  return *id_;
}
inline void Task__CName::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task._CName.id)
}
inline void Task__CName::set_id(const char* value) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task._CName.id)
}
inline void Task__CName::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task._CName.id)
}
inline ::std::string* Task__CName::mutable_id() {
  set_has_id();
  if (id_ == _default_id_) {
    id_ = new ::std::string(*_default_id_);
  }
  // @@protoc_insertion_point(field_mutable:res.Task._CName.id)
  return id_;
}
inline ::std::string* Task__CName::release_id() {
  clear_has_id();
  if (id_ == _default_id_) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(_default_id_);
    return temp;
  }
}
inline void Task__CName::set_allocated_id(::std::string* id) {
  if (id_ != _default_id_) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(_default_id_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task._CName.id)
}

// optional string name = 2 [default = "\345\220\215\345\255\227"];
inline bool Task__CName::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task__CName::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task__CName::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task__CName::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Task__CName::name() const {
  // @@protoc_insertion_point(field_get:res.Task._CName.name)
  return *name_;
}
inline void Task__CName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task._CName.name)
}
inline void Task__CName::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task._CName.name)
}
inline void Task__CName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task._CName.name)
}
inline ::std::string* Task__CName::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  // @@protoc_insertion_point(field_mutable:res.Task._CName.name)
  return name_;
}
inline ::std::string* Task__CName::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Task__CName::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task._CName.name)
}

// optional string desc = 3 [default = "\346\217\217\350\277\260"];
inline bool Task__CName::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task__CName::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task__CName::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task__CName::clear_desc() {
  if (desc_ != _default_desc_) {
    desc_->assign(*_default_desc_);
  }
  clear_has_desc();
}
inline const ::std::string& Task__CName::desc() const {
  // @@protoc_insertion_point(field_get:res.Task._CName.desc)
  return *desc_;
}
inline void Task__CName::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task._CName.desc)
}
inline void Task__CName::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task._CName.desc)
}
inline void Task__CName::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task._CName.desc)
}
inline ::std::string* Task__CName::mutable_desc() {
  set_has_desc();
  if (desc_ == _default_desc_) {
    desc_ = new ::std::string(*_default_desc_);
  }
  // @@protoc_insertion_point(field_mutable:res.Task._CName.desc)
  return desc_;
}
inline ::std::string* Task__CName::release_desc() {
  clear_has_desc();
  if (desc_ == _default_desc_) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(_default_desc_);
    return temp;
  }
}
inline void Task__CName::set_allocated_desc(::std::string* desc) {
  if (desc_ != _default_desc_) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(_default_desc_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task._CName.desc)
}

// optional string obj = 4 [default = "\347\233\256\346\240\207"];
inline bool Task__CName::has_obj() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task__CName::set_has_obj() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task__CName::clear_has_obj() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task__CName::clear_obj() {
  if (obj_ != _default_obj_) {
    obj_->assign(*_default_obj_);
  }
  clear_has_obj();
}
inline const ::std::string& Task__CName::obj() const {
  // @@protoc_insertion_point(field_get:res.Task._CName.obj)
  return *obj_;
}
inline void Task__CName::set_obj(const ::std::string& value) {
  set_has_obj();
  if (obj_ == _default_obj_) {
    obj_ = new ::std::string;
  }
  obj_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task._CName.obj)
}
inline void Task__CName::set_obj(const char* value) {
  set_has_obj();
  if (obj_ == _default_obj_) {
    obj_ = new ::std::string;
  }
  obj_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task._CName.obj)
}
inline void Task__CName::set_obj(const char* value, size_t size) {
  set_has_obj();
  if (obj_ == _default_obj_) {
    obj_ = new ::std::string;
  }
  obj_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task._CName.obj)
}
inline ::std::string* Task__CName::mutable_obj() {
  set_has_obj();
  if (obj_ == _default_obj_) {
    obj_ = new ::std::string(*_default_obj_);
  }
  // @@protoc_insertion_point(field_mutable:res.Task._CName.obj)
  return obj_;
}
inline ::std::string* Task__CName::release_obj() {
  clear_has_obj();
  if (obj_ == _default_obj_) {
    return NULL;
  } else {
    ::std::string* temp = obj_;
    obj_ = const_cast< ::std::string*>(_default_obj_);
    return temp;
  }
}
inline void Task__CName::set_allocated_obj(::std::string* obj) {
  if (obj_ != _default_obj_) {
    delete obj_;
  }
  if (obj) {
    set_has_obj();
    obj_ = obj;
  } else {
    clear_has_obj();
    obj_ = const_cast< ::std::string*>(_default_obj_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task._CName.obj)
}

// optional string type = 5 [default = "\347\261\273\345\236\213"];
inline bool Task__CName::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task__CName::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task__CName::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task__CName::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& Task__CName::type() const {
  // @@protoc_insertion_point(field_get:res.Task._CName.type)
  return *type_;
}
inline void Task__CName::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task._CName.type)
}
inline void Task__CName::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task._CName.type)
}
inline void Task__CName::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task._CName.type)
}
inline ::std::string* Task__CName::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  // @@protoc_insertion_point(field_mutable:res.Task._CName.type)
  return type_;
}
inline ::std::string* Task__CName::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void Task__CName::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task._CName.type)
}

// -------------------------------------------------------------------

// Task

// required uint32 id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Task::id() const {
  // @@protoc_insertion_point(field_get:res.Task.id)
  return id_;
}
inline void Task::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:res.Task.id)
}

// optional uint32 type = 2;
inline bool Task::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Task::type() const {
  // @@protoc_insertion_point(field_get:res.Task.type)
  return type_;
}
inline void Task::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:res.Task.type)
}

// optional string name = 3;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:res.Task.name)
  return *name_;
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task.name)
}
inline void Task::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task.name)
}
inline void Task::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task.name)
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:res.Task.name)
  return name_;
}
inline ::std::string* Task::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task.name)
}

// optional string desc = 4;
inline bool Task::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Task::desc() const {
  // @@protoc_insertion_point(field_get:res.Task.desc)
  return *desc_;
}
inline void Task::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:res.Task.desc)
}
inline void Task::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:res.Task.desc)
}
inline void Task::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:res.Task.desc)
}
inline ::std::string* Task::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:res.Task.desc)
  return desc_;
}
inline ::std::string* Task::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task.desc)
}

// optional .res.TaskObj obj = 5;
inline bool Task::has_obj() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_obj() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_obj() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_obj() {
  if (obj_ != NULL) obj_->::res::TaskObj::Clear();
  clear_has_obj();
}
inline const ::res::TaskObj& Task::obj() const {
  // @@protoc_insertion_point(field_get:res.Task.obj)
  return obj_ != NULL ? *obj_ : *default_instance_->obj_;
}
inline ::res::TaskObj* Task::mutable_obj() {
  set_has_obj();
  if (obj_ == NULL) obj_ = new ::res::TaskObj;
  // @@protoc_insertion_point(field_mutable:res.Task.obj)
  return obj_;
}
inline ::res::TaskObj* Task::release_obj() {
  clear_has_obj();
  ::res::TaskObj* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void Task::set_allocated_obj(::res::TaskObj* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    set_has_obj();
  } else {
    clear_has_obj();
  }
  // @@protoc_insertion_point(field_set_allocated:res.Task.obj)
}

// -------------------------------------------------------------------

// TaskTable

// repeated .res.Task list = 1;
inline int TaskTable::list_size() const {
  return list_.size();
}
inline void TaskTable::clear_list() {
  list_.Clear();
}
inline const ::res::Task& TaskTable::list(int index) const {
  // @@protoc_insertion_point(field_get:res.TaskTable.list)
  return list_.Get(index);
}
inline ::res::Task* TaskTable::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:res.TaskTable.list)
  return list_.Mutable(index);
}
inline ::res::Task* TaskTable::add_list() {
  // @@protoc_insertion_point(field_add:res.TaskTable.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::res::Task >&
TaskTable::list() const {
  // @@protoc_insertion_point(field_list:res.TaskTable.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::res::Task >*
TaskTable::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:res.TaskTable.list)
  return &list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace res

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_res_2ftask_2eproto__INCLUDED
